// ++ Вишневский А. 28.03.2023 
#Область ЛогированиеСообщенийВФайл
// если на управляемых формах , то вызов только со стороны сервера 
// обший порядок работы :
// 1. Инициализация структуры логирования
// 2. Использование
// 3. Завернение логирования , это не обязательно , но для освобождения памяти и захвата файла  желательно сделать . 


// Инициализация структуры в которой сохранены параметры записи данных в файл.
//
// Параметры:
//  Каталог  				- Строка 		- Каталог сохранения лог файлов
//  ИмяФайла  				- Строка 		- Имя файла логирования , если не задан то текущая дата . Если файла нет, то он будет создан.
//  ВыводитьДату			- Булево 		- Если Итина, то временная метка содержит дату . Дата не всегда нужна , как правило в логах
//										  	  дата содержится в имени файла. 	
//  ВыводитьВКонсоль		- Булево 		- Дублировать сообщения в консоль выовда.
//  СоответствияСтатусов	- Соответствие 	- При выводе в консоль текстовое событие может соответствовать 
//
// Возвращаемое значение:
//   Структура   			- Структура содержащая параметры выода сообщений в файл, используется в дальнейшем 
//							  для вывода сообщений функцией ЗаписатьВЛог()
//
Функция ИнициализацияЛогированияВФайл(Каталог, ИмяФайла = "" , ВыводитьДату = Ложь , ВыводитьВКонсоль = ложь, СоответствияСтатусов = Неопределено ) Экспорт
	Лог  =новый Структура;
	
	Лог.Вставить("ВыводитьВКонсоль", ВыводитьВКонсоль);
	Лог.Вставить("ВыводитьДату", ВыводитьДату); //Дата по умолчанию не нужна , так как дата есть в имени файла
	Лог.Вставить("ПривестиКМестномуВремени", Истина); //По умолчанию приводим к часовому поясу сервера
	Лог.Вставить("РазделительПриДописыванииНовогоБлока", ""); // для разделения блоков в одном файле при разных итеррациях сообщений

	
	Если ПустаяСтрока(Каталог) Тогда
		Лог.Вставить("ОшибкаИнициализации", Истина);
		Лог.Вставить("ОписаниеОшибкиИнициализации", "Не задан каталог для сохранения файлов логирования.");
		возврат лог;
	КонецЕсли;
	
	// проверка наличия каталога 
	ФайлКаталога = новый Файл(Каталог);
	Если не ФайлКаталога.Существует() Тогда
		Лог.Вставить("ОшибкаИнициализации", Истина);
		Лог.Вставить("ОписаниеОшибкиИнициализации", "Не найден каталог для сохранения файлов логирования.");
		возврат лог;
	КонецЕсли;
	
	// если надо добавляем "\"
	КаталогРез = ?(Прав(Каталог,1)="\",Каталог,Каталог+"\");
	
	// не всегда надо задавать имя , даты может быть достаточно.
	ИмяФайлаРез = ?(ПустаяСтрока(ИмяФайла),Формат(ТекущаяДата(), "ДФ=yyyy-MM-dd"),ИмяФайла);

	ПутьКФайлуЛогирования = КаталогРез+ИмяФайлаРез;
	
	Лог.Вставить("ПутьКФайлуЛогирования", ПутьКФайлуЛогирования);
	
	ФайлЛогирования = Новый Файл(ПутьКФайлуЛогирования);
	
	Лог.Вставить("ВывестиРазделительБлоков", ФайлЛогирования.Существует()); // если файл есть, то там скорее всего есть данные 
	
	
	Попытка
		Лог.Вставить("ФайлЛога", Новый ЗаписьТекста(ПутьКФайлуЛогирования,,,Истина));
	Исключение
		Лог.Вставить("ОшибкаИнициализации", Истина);
		Лог.Вставить("ОписаниеОшибкиИнициализации", "Не возможно открыть\создать файл лога. Причина: "+ОписаниеОшибки());
		возврат лог;
	КонецПопытки;
	
	// Определения соответствия статусов сообщения текстовым представлениям которые задал программист
	Если СоответствияСтатусов = Неопределено Тогда
		СоответствияСтатусов = Новый Соответствие;
	КонецЕсли;
	
	СоответствияСтатусов.Вставить("-",	СтатусСообщения.Обычное);
	СоответствияСтатусов.Вставить("!",	СтатусСообщения.Важное);
	СоответствияСтатусов.Вставить("ERR",СтатусСообщения.ОченьВажное);
	СоответствияСтатусов.Вставить("deb",СтатусСообщения.Информация);
	
	СоответствияСтатусов.Вставить("ИНФОРМАЦИЯ",	СтатусСообщения.Обычное);
	СоответствияСтатусов.Вставить("ПРЕДУПРЕЖДЕНИЕ",	СтатусСообщения.Важное);
	СоответствияСтатусов.Вставить("ОШИБКА",СтатусСообщения.ОченьВажное);
	СоответствияСтатусов.Вставить("ОТЛАДКА",СтатусСообщения.Информация);
	
	Лог.Вставить("СоответствияСтатусов",СоответствияСтатусов);
	
	// инициализация прошла успешно
	Лог.Вставить("ОшибкаИнициализации", ложь);

	возврат Лог;
КонецФункции // ()

// Вывод сообщения в файл лога 
//
// Параметры:
//  Лог  		- Структура - инициализируется функцией ИнициализацияЛогированияВФайл
//  Сообщение  	- Строка 	- содержит текст сообщения
//  Событие  	- Строка 	- Варианты :	{"-", "ERR" , "!", "deb"} 								или 
//											{"ИНФОРМАЦИЯ", "ОШИБКА" , "ПРЕДУПРЕЖДЕНИЕ", "ОТЛАДКА"}
//  ЗаписыватьФайл - Булево	- производить запись в файл после вывода строки, либо нет 
//
// Возвращаемое значение:
//   Булево   	- успех записа сообщения в файл.
Функция ЗаписатьВЛог(Лог, Сообщение , Событие = "-" , ЗаписыватьФайл = Ложь ) экспорт
	                                             
	Если Лог.ОшибкаИнициализации Тогда           
		Возврат истина;
	КонецЕсли;
	
	ДатаСообщенияУниверсальнаяМС	= ТекущаяУниверсальнаяДатаВМиллисекундах();
	ДатаМиллисекунды             	= ДатаСообщенияУниверсальнаяМС % 1000; 
	ДатаПредставлениеМС				= Формат(ДатаСообщенияУниверсальнаяМС % 1000, "ЧЦ=3; ЧН=0; ЧВН=; ЧГ=0");
	
	// вычисляем дату и при необходимости приводим ее к местному времени
	Если Лог.ПривестиКМестномуВремени Тогда
		ДатаЗначение = МестноеВремя(Дата(1, 1, 1) + ДатаСообщенияУниверсальнаяМС / 1000);
	Иначе
		ДатаЗначение = Дата(1, 1, 1) + ДатаСообщенияУниверсальнаяМС / 1000;
	КонецЕсли;	
		
	// не всегда нужна дата , дата может быть в имени файла .
	Если Лог.ВыводитьДату Тогда
		ДатаПредставление = Строка(ДатаЗначение); 
	Иначе 
		ДатаПредставление = Формат(ДатаЗначение, "ДЛФ=T"); 
	КонецЕсли;
	
	ПолноеСообщение = СтрШаблон("%1.%2 [%3]: %4", ДатаПредставление, ДатаПредставлениеМС, Событие,Сообщение);
	
	// если нужно то выводим разлелитель , но один раз .
	Если Лог.ВывестиРазделительБлоков Тогда
		Лог.ВывестиРазделительБлоков = ложь;
		Лог.ФайлЛога.ЗаписатьСтроку(Лог.РазделительПриДописыванииНовогоБлока);
	КонецЕсли;
	
	Лог.ФайлЛога.ЗаписатьСтроку(ПолноеСообщение);
	
	Если Лог.ВыводитьВКонсоль Тогда
		Сообщить(ПолноеСообщение,Лог.СоответствияСтатусов.Получить(Событие));
	КонецЕсли;
	
	Если ЗаписыватьФайл = Истина Тогда
		Лог.ФайлЛога.Закрыть();
		Лог.ФайлЛога.Открыть(Лог.ПутьКФайлуЛогирования,,,Истина);
	КонецЕсли;	
	
	Возврат истина;
КонецФункции // ()



// Закрывает файл логирования
// Параметры:
//  Лог  		- Структура - инициализируется функцией ИнициализацияЛогированияВФайл
Процедура ЗавершитьЛогирование(Лог) Экспорт 
	
	Лог.ФайлЛога.Закрыть();
	
	Лог = Неопределено;
	
КонецПроцедуры 

#КонецОбласти
// -- Вишневский А. 28.03.2023 

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МЕТАДАННЫМИ

// Функция возвращает имя табличной части, к которой принадлежит переданная строка
//
// Параметры
//  СтрокаТабличнойЧасти - ссылка на строку табличной части
//
// Возвращаемое значение:
//   Строка - имя табличной части, как оно задано в конфигураторе
//
Функция ПолучитьИмяТабличнойЧастиПоСсылкеНаСтроку(СтрокаТабличнойЧасти) Экспорт
	
	ИмяТабличнойЧасти = Метаданные.НайтиПоТипу(ТипЗнч(СтрокаТабличнойЧасти)).Имя;
	Возврат ИмяТабличнойЧасти;
	
КонецФункции // ПолучитьИмяТабличнойЧастиПоСсылкеНаСтроку()

// Функция возвращает метаданные документа, которому принадлежит переданная строка
//
// Параметры
//  СтрокаТабличнойЧасти - ссылка на строку табличной части
//
// Возвращаемое значение:
//   Метаданные - метаданные документа, как оно задано в конфигураторе
//
Функция ПолучитьМетаданныеДокументаПоСсылкеНаСтроку(СтрокаТабличнойЧасти) Экспорт
	
	МетаданныеДокумента = Метаданные.НайтиПоТипу(ТипЗнч(СтрокаТабличнойЧасти)).Родитель();
	Возврат МетаданныеДокумента;
	
КонецФункции // ПолучитьМетаданныеДокументаПоСсылкеНаСтроку()

// Позволяет определить есть ли среди реквизитов табличной части документа
// реквизит с переданным именем.
//
// Параметры: 
//  ИмяРеквизита - строковое имя искомого реквизита, 
//  МетаданныеДокумента - объект описания метаданных документа, среди реквизитов которого производится поиск.
//  ИмяТабЧасти  - строковое имя табличной части документа, среди реквизитов которого производится поиск
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьРеквизитТабЧастиДокумента(ИмяРеквизита, МетаданныеДокумента, ИмяТабЧасти) Экспорт
	
	ТабЧасть = МетаданныеДокумента.ТабличныеЧасти.Найти(ИмяТабЧасти);
	Если ТабЧасть = Неопределено Тогда // Нет такой таб. части в документе
		Возврат Ложь;
	Иначе
		Если ТабЧасть.Реквизиты.Найти(ИмяРеквизита) = Неопределено Тогда
			Возврат Ложь;
		Иначе
			Возврат Истина;
		КонецЕсли;
	КонецЕсли;
	
КонецФункции // ЕстьРеквизитТабЧастиДокумента()


// Если в шапке переданного документа есть реквизит с указанным именем, то возвращается его значение.
// Если такого реквизита нет - возвращается Неопределено.
//
// Параметры:
//  ИмяРеквизита - Строка. Имя искомого реквизита.
//  ДокументОбъект - объект переданного документа.
//  МетаданныеДокумента - Метаданные переданного документа.
//  ПустоеЗначение - значение, которое должно вернуться, если в шапке нет такого реквизита,
//  если не передано, то возвращается значение Неопределено.
//
// Возвращаемое значение:
//  Значение реквизита - значение найденного реквизита или ПустоеЗначение.
//
Функция ПолучитьРеквизитШапки(ИмяРеквизита, ДокументОбъект, МетаданныеДокумента, ПустоеЗначение = Неопределено) Экспорт
	
	ЗначениеРеквизита = ?(МетаданныеДокумента.Реквизиты.Найти(ИмяРеквизита) <> Неопределено,
	ДокументОбъект[ИмяРеквизита], ПустоеЗначение);
	
	Возврат ЗначениеРеквизита;
	
КонецФункции // ПолучитьРеквизитШапки()





// ++Бобрышов А. 12.10.2022 Механизм проверки того, является ли база рабочей
Процедура ПередВыполнениемРегламентногоЗадания(Отказ = Ложь) Экспорт
	
	СтрокаСообщения = "";
	Отказ = НЕ ЭтоРабочаяБаза(СтрокаСообщения);
	
	Если Отказ Тогда
		
		ЗаписьЖурналаРегистрации("Перед выполнением регламентного задания",
			УровеньЖурналаРегистрации.Предупреждение, , , СтрокаСообщения);
		
	КонецЕсли;
	
КонецПроцедуры

Функция ЭтоРабочаяБаза(СтрокаСообщения = "") Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	ЭтоРабочаяБаза = Истина;
	
	//Если ПолучитьФункциональнуюОпцию("ИспользоватьПроверкуРабочейБазы") Тогда 
		
		СтрокаПодключенияКИнформационнойБазе = НРег(СтрокаСоединенияИнформационнойБазы());
		СтрокаПодключенияКРабочейБазе = НРег(Константы.ксп_СтрокаПодключенияКРабочейБазе.Получить());
		
		ЭтоРабочаяБаза = ЗначениеЗаполнено(СтрокаПодключенияКРабочейБазе)
					И СтрокаПодключенияКИнформационнойБазе = СтрокаПодключенияКРабочейБазе;
					
		СтрокаСообщения = СтрШаблон("Не пройдена проверка рабочей базы.
			|Строка подключения к рабочей базе %1, строка подключения к текущей базе %2",
			СтрокаПодключенияКРабочейБазе, СтрокаПодключенияКИнформационнойБазе);
			
		
	//КонецЕсли;
	
	Возврат ЭтоРабочаяБаза;
	
КонецФункции
// --Бобрышов А. 12.10.2022 Механизм проверки того, является ли база рабочей
